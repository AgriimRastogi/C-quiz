[
  {
    "id": 1,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x = 5;\nprintf(\"%d %d\", x++, ++x);",
    "options": ["5 7", "5 6", "Undefined behavior", "6 7"],
    "answerIndex": 2,
    "explanation": "The variable x is modified more than once between sequence points without an intervening sequence point. C standard defines this as undefined behavior, so the result cannot be relied upon."
  },
  {
    "id": 2,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is modifying a variable multiple times between sequence points undefined?",
    "options": [
      "Compiler optimization issue",
      "CPU limitation",
      "C standard does not define evaluation order",
      "Memory corruption"
    ],
    "answerIndex": 2,
    "explanation": "The C standard intentionally leaves the order of evaluation unspecified. Modifying the same object multiple times without a sequence point makes the behavior undefined, allowing compilers to optimize aggressively."
  },
  {
    "id": 3,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a[5]={1,2,3,4,5};\nprintf(\"%d\", *(a + *(a + 1)));",
    "options": ["2", "3", "4", "Undefined"],
    "answerIndex": 2,
    "explanation": "a[1] is 2, so *(a + 2) accesses a[2], which is 3. But note indexing: *(a + *(a + 1)) → *(a + 2) → 3."
  },
  {
    "id": 4,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does pointer arithmetic scale by sizeof(type)?",
    "options": [
      "Hardware requirement",
      "Compiler design choice",
      "Correct memory addressing of elements",
      "Performance optimization"
    ],
    "answerIndex": 2,
    "explanation": "Pointer arithmetic must move by the size of the pointed type to correctly traverse elements in contiguous memory. Without scaling, accessing array elements would be incorrect."
  },
  {
    "id": 5,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint *p = (int*)malloc(sizeof(int));\n*p = 10;\nfree(p);\nprintf(\"%d\", *p);",
    "options": ["10", "0", "Garbage value", "Undefined behavior"],
    "answerIndex": 3,
    "explanation": "After free(), the pointer becomes dangling. Dereferencing a freed pointer results in undefined behavior, even if the memory appears unchanged."
  },

  {
    "id": 6,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is dereferencing a dangling pointer undefined behavior?",
    "options": [
      "Memory is erased immediately",
      "Compiler inserts runtime checks",
      "Memory may be reused or unmapped",
      "Only causes memory leak"
    ],
    "answerIndex": 2,
    "explanation": "Freed memory may be reused by the allocator or returned to the OS. Accessing it can corrupt allocator metadata or crash the program."
  },
  {
    "id": 7,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nprintf(\"%zu\", sizeof(\"hello\"));",
    "options": ["5", "6", "Depends on compiler", "Undefined"],
    "answerIndex": 1,
    "explanation": "String literals include the null terminator. \"hello\" has 5 characters plus '\\0', so sizeof is 6."
  },
  {
    "id": 8,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is sizeof evaluated at compile time?",
    "options": [
      "For speed",
      "Because it is an operator, not a function",
      "To reduce memory usage",
      "Because runtime size is unknown"
    ],
    "answerIndex": 1,
    "explanation": "sizeof is an operator whose result is known at compile time for all non-VLA operands, allowing better optimization and no runtime overhead."
  },
  {
    "id": 9,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=1;\nprintf(\"%d\", (a++, a+5));",
    "options": ["6", "5", "Undefined behavior", "Compilation error"],
    "answerIndex": 0,
    "explanation": "The comma operator introduces a sequence point. a++ is evaluated first, then a+5 uses the incremented value, resulting in 6."
  },
  {
    "id": 10,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does the comma operator introduce a sequence point?",
    "options": [
      "Syntax convenience",
      "To force left-to-right evaluation",
      "To avoid undefined behavior",
      "Compiler requirement"
    ],
    "answerIndex": 1,
    "explanation": "The comma operator guarantees left operand is fully evaluated before the right, making it useful to avoid undefined behavior in complex expressions."
  },

  {
    "id": 11,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=10;\nint *p=&x;\nprintf(\"%d\", ++*p);",
    "options": ["10", "11", "Undefined", "Compilation error"],
    "answerIndex": 1,
    "explanation": "++ has higher precedence than *, so ++*p increments the value pointed to by p. x becomes 11."
  },
  {
    "id": 12,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is ++*p valid but *++p different?",
    "options": [
      "Same operation",
      "Operator precedence difference",
      "Undefined behavior",
      "Compiler-dependent"
    ],
    "answerIndex": 1,
    "explanation": "Operator precedence determines binding. ++*p increments the value, while *++p increments the pointer first, then dereferences it."
  },
  {
    "id": 13,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a[]={10,20,30};\nint *p=a;\nprintf(\"%d\", *p+++1);",
    "options": ["11", "20", "21", "Undefined"],
    "answerIndex": 0,
    "explanation": "*p+++1 is parsed as (*(p++)) + 1. p++ yields 10, then +1 gives 11."
  },
  {
    "id": 14,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is free(NULL) safe?",
    "options": [
      "Does nothing by standard",
      "Compiler checks it",
      "OS ignores it",
      "Undefined behavior"
    ],
    "answerIndex": 0,
    "explanation": "The C standard explicitly specifies that calling free with NULL has no effect, making it safe."
  },
  {
    "id": 15,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=1;\nprintf(\"%d\", sizeof(x++));",
    "options": ["1", "2", "Depends", "Undefined"],
    "answerIndex": 0,
    "explanation": "The operand of sizeof is not evaluated. x++ is never executed, so x remains unchanged and sizeof(int) is printed."
  },

  {
    "id": 16,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does sizeof not evaluate its operand?",
    "options": [
      "Optimization only",
      "Because it is compile-time operator",
      "To avoid side effects",
      "Undefined behavior prevention"
    ],
    "answerIndex": 1,
    "explanation": "sizeof is defined to operate on types or expressions without evaluating them, enabling compile-time size computation."
  },
  {
    "id": 17,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=5;\nprintf(\"%d\", x+++x);",
    "options": ["10", "11", "Undefined behavior", "Compilation error"],
    "answerIndex": 2,
    "explanation": "x is modified and read again without a sequence point. This violates C rules and causes undefined behavior."
  },
  {
    "id": 18,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is evaluation order important in C?",
    "options": [
      "Affects performance",
      "Affects readability",
      "Can cause undefined behavior",
      "Only affects debugging"
    ],
    "answerIndex": 2,
    "explanation": "C allows compilers to choose evaluation order. If code relies on a specific order, it may break or become undefined."
  },

  {
    "id": 19,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=0;\nprintf(\"%d\", a && ++a);",
    "options": ["0", "1", "Undefined", "Compilation error"],
    "answerIndex": 0,
    "explanation": "Logical AND short-circuits. Since a is 0, ++a is never evaluated."
  },
  {
    "id": 20,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does short-circuiting prevent undefined behavior?",
    "options": [
      "Compiler ignores second operand",
      "Second operand not evaluated",
      "Runtime check",
      "Optimization"
    ],
    "answerIndex": 1,
    "explanation": "Short-circuit operators guarantee that the second operand is not evaluated if the result is already determined."
  },
  {
    "id": 21,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=1;\nprintf(\"%d\", a+++a+++a);",
    "options": ["3", "4", "Undefined behavior", "Compilation error"],
    "answerIndex": 2,
    "explanation": "The variable 'a' is modified multiple times between sequence points without a defined evaluation order. This violates the C standard and results in undefined behavior."
  },
  {
    "id": 22,
    "type": "concept",
    "difficulty": "superhard",
    "question": "What is a sequence point in C?",
    "options": [
      "A compiler optimization step",
      "A point where all side effects are complete",
      "A memory barrier",
      "A runtime checkpoint"
    ],
    "answerIndex": 1,
    "explanation": "A sequence point is a point in execution where all side effects of previous evaluations are guaranteed to be complete before the next evaluation begins."
  },
  {
    "id": 23,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=0;\nprintf(\"%d\", x++ + ++x);",
    "options": ["2", "1", "Undefined behavior", "Compilation error"],
    "answerIndex": 2,
    "explanation": "x is modified twice without an intervening sequence point. The order of evaluation is undefined, so the result is undefined behavior."
  },
  {
    "id": 24,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does C allow undefined behavior?",
    "options": [
      "To simplify syntax",
      "To support low-level optimizations",
      "To make debugging harder",
      "To reduce compiler size"
    ],
    "answerIndex": 1,
    "explanation": "Undefined behavior allows compilers to generate highly optimized code without being constrained by edge-case semantics."
  },
  {
    "id": 25,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a[]={1,2,3};\nprintf(\"%d\", 2[a]);",
    "options": ["1", "2", "3", "Compilation error"],
    "answerIndex": 2,
    "explanation": "Array subscripting is defined as *(a + b). Thus 2[a] is equivalent to a[2], which is 3."
  },

  {
    "id": 26,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is a[b] equivalent to *(a + b)?",
    "options": [
      "Compiler trick",
      "Historical accident",
      "Array-pointer equivalence",
      "Undefined behavior"
    ],
    "answerIndex": 2,
    "explanation": "In expressions, array names decay to pointers. The subscript operator is defined in terms of pointer arithmetic."
  },
  {
    "id": 27,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nprintf(\"%d\", sizeof(char) == 1);",
    "options": ["0", "1", "Depends on compiler", "Undefined"],
    "answerIndex": 1,
    "explanation": "The C standard guarantees sizeof(char) is exactly 1 byte."
  },
  {
    "id": 28,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is sizeof(char) always 1?",
    "options": [
      "Hardware requirement",
      "Language definition",
      "Compiler optimization",
      "Memory alignment"
    ],
    "answerIndex": 1,
    "explanation": "The C standard defines a byte as the size of char, making sizeof(char) equal to 1 by definition."
  },
  {
    "id": 29,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=5;\nprintf(\"%d\", a = a + (a = 3));",
    "options": ["8", "6", "3", "Undefined behavior"],
    "answerIndex": 3,
    "explanation": "The variable 'a' is modified and read again without a sequence point. This results in undefined behavior."
  },
  {
    "id": 30,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is self-assignment with side effects dangerous?",
    "options": [
      "Performance loss",
      "Compiler warning",
      "Undefined evaluation order",
      "Stack overflow"
    ],
    "answerIndex": 2,
    "explanation": "When a variable is modified and read again without a defined order, the result becomes undefined."
  },

  {
    "id": 31,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=1;\nprintf(\"%d\", ++x * ++x);",
    "options": ["4", "6", "Undefined behavior", "Compilation error"],
    "answerIndex": 2,
    "explanation": "x is modified twice between sequence points. The order of evaluation of operands of * is unspecified, causing undefined behavior."
  },
  {
    "id": 32,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is operand evaluation order unspecified in C?",
    "options": [
      "Language oversight",
      "To enable optimization freedom",
      "Hardware constraint",
      "Legacy compatibility"
    ],
    "answerIndex": 1,
    "explanation": "Leaving evaluation order unspecified allows compilers to generate more efficient code for different architectures."
  },
  {
    "id": 33,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=5;\nprintf(\"%d\", x + ++x);",
    "options": ["11", "10", "Undefined behavior", "Compilation error"],
    "answerIndex": 2,
    "explanation": "The value of x is modified and read again without a sequence point, resulting in undefined behavior."
  },
  {
    "id": 34,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Which operator introduces a sequence point?",
    "options": ["+", "*", ",", "[]"],
    "answerIndex": 2,
    "explanation": "The comma operator guarantees that the left operand is fully evaluated before the right operand."
  },
  {
    "id": 35,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=1;\nprintf(\"%d\", (a++, a++, a));",
    "options": ["1", "2", "3", "Undefined behavior"],
    "answerIndex": 2,
    "explanation": "The comma operator creates sequence points. a is incremented twice in order, resulting in a value of 3."
  },

  {
    "id": 36,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is the comma operator safer than chained arithmetic operators?",
    "options": [
      "Better performance",
      "Enforces evaluation order",
      "Avoids syntax errors",
      "Reduces memory usage"
    ],
    "answerIndex": 1,
    "explanation": "The comma operator guarantees left-to-right evaluation, preventing undefined behavior caused by ambiguous order."
  },
  {
    "id": 37,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a[]={10,20,30};\nint *p=a;\nprintf(\"%d\", *++p);",
    "options": ["10", "20", "30", "Undefined"],
    "answerIndex": 1,
    "explanation": "++p increments the pointer to point to a[1], then dereferencing yields 20."
  },
  {
    "id": 38,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does ++p change the pointer but p++ return old address?",
    "options": [
      "Compiler rule",
      "Post vs pre increment semantics",
      "Undefined behavior",
      "Architecture dependent"
    ],
    "answerIndex": 1,
    "explanation": "Pre-increment changes the value before use, while post-increment returns the old value before incrementing."
  },
  {
    "id": 39,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a[]={1,2,3};\nprintf(\"%d\", *a++);",
    "options": ["1", "2", "3", "Undefined"],
    "answerIndex": 0,
    "explanation": "*a++ is parsed as *(a++). The value at original a is printed, then the pointer is incremented."
  },
  {
    "id": 40,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is *(a++) valid but (++a) invalid for arrays?",
    "options": [
      "Arrays are constant pointers",
      "Compiler bug",
      "Undefined behavior",
      "Memory protection"
    ],
    "answerIndex": 0,
    "explanation": "Array names decay to constant pointers. You can increment the pointer expression, but not the array itself."
  },

  {
    "id": 41,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nprintf(\"%d\", printf(\"Hello\"));",
    "options": ["Hello5", "5Hello", "Hello", "Compilation error"],
    "answerIndex": 0,
    "explanation": "printf returns the number of characters printed. \"Hello\" prints first, then 5 is printed."
  },
  {
    "id": 42,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does printf return number of characters printed?",
    "options": [
      "Historical reason",
      "For error checking and formatting control",
      "Optimization",
      "POSIX requirement"
    ],
    "answerIndex": 1,
    "explanation": "The return value allows programs to detect output errors and manage formatted output dynamically."
  },
  {
    "id": 43,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=5;\nprintf(\"%d\", (x>3) ? x++ : ++x);",
    "options": ["5", "6", "Undefined", "Compilation error"],
    "answerIndex": 0,
    "explanation": "The conditional operator evaluates only one branch. Since x>3 is true, x++ executes and prints 5."
  },
  {
    "id": 44,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does the conditional operator avoid undefined behavior here?",
    "options": [
      "Compiler optimization",
      "Only one branch evaluated",
      "Sequence point insertion",
      "Undefined but safe"
    ],
    "answerIndex": 1,
    "explanation": "The conditional operator guarantees that only one of the second or third operands is evaluated."
  },
  {
    "id": 45,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=0;\nprintf(\"%d\", a || a++);",
    "options": ["0", "1", "Undefined", "Compilation error"],
    "answerIndex": 1,
    "explanation": "a is initially 0, so logical OR evaluates the second operand. a++ increments a, making the result true."
  },

  {
    "id": 46,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why do logical operators short-circuit?",
    "options": [
      "Performance only",
      "Language rule",
      "Prevent unnecessary evaluation",
      "All of the above"
    ],
    "answerIndex": 3,
    "explanation": "Short-circuiting improves performance, prevents errors, and is mandated by the language specification."
  },
  {
    "id": 47,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=5;\nprintf(\"%d\", a && ++a && a++);",
    "options": ["0", "1", "Undefined", "Compilation error"],
    "answerIndex": 1,
    "explanation": "Logical AND evaluates left to right with short-circuiting. All operands are evaluated safely without undefined behavior."
  },
  {
    "id": 48,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is logical AND safer than bitwise AND in expressions with side effects?",
    "options": [
      "Different precedence",
      "Short-circuiting behavior",
      "Compiler optimization",
      "Undefined behavior avoidance"
    ],
    "answerIndex": 1,
    "explanation": "Logical AND stops evaluation once the result is determined, preventing unintended side effects."
  },
  {
    "id": 49,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nprintf(\"%d\", sizeof(1.0));",
    "options": ["4", "8", "Depends on compiler", "Undefined"],
    "answerIndex": 1,
    "explanation": "1.0 is a double literal by default, and sizeof(double) is typically 8 bytes."
  },
  {
    "id": 50,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why are floating-point literals double by default?",
    "options": [
      "Historical design",
      "Precision preference",
      "Performance",
      "Compiler requirement"
    ],
    "answerIndex": 1,
    "explanation": "Using double by default provides higher precision and avoids accidental loss of accuracy."
  },

  {
    "id": 51,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=1;\nprintf(\"%d\", sizeof(x++));",
    "options": ["1", "2", "Depends", "Undefined"],
    "answerIndex": 0,
    "explanation": "sizeof does not evaluate its operand, so x++ is not executed and x remains unchanged."
  },
  {
    "id": 52,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is sizeof not a function?",
    "options": [
      "Syntax simplicity",
      "Avoid runtime cost",
      "Compile-time evaluation",
      "All of the above"
    ],
    "answerIndex": 3,
    "explanation": "sizeof is an operator designed for compile-time evaluation without runtime overhead."
  },
  {
    "id": 53,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a[]={1,2,3};\nprintf(\"%d\", *(&a + 1) - a[0]);",
    "options": ["2", "3", "Undefined behavior", "Garbage"],
    "answerIndex": 2,
    "explanation": "&a points to the whole array, not its first element. Pointer arithmetic here is invalid and causes undefined behavior."
  },
  {
    "id": 54,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is &a different from a?",
    "options": [
      "Same thing",
      "Different pointer types",
      "Compiler bug",
      "Undefined behavior"
    ],
    "answerIndex": 1,
    "explanation": "&a is a pointer to an array, while a decays to a pointer to its first element."
  },
  {
    "id": 55,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a[]={1,2,3};\nint *p=(int*)(&a+1);\nprintf(\"%d\", *(p-1));",
    "options": ["1", "2", "3", "Undefined behavior"],
    "answerIndex": 3,
    "explanation": "Casting &a+1 to int* and dereferencing relies on invalid pointer arithmetic, leading to undefined behavior."
  },

  {
    "id": 56,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is pointer casting dangerous?",
    "options": [
      "Breaks alignment",
      "Breaks strict aliasing",
      "Hides bugs",
      "All of the above"
    ],
    "answerIndex": 3,
    "explanation": "Improper pointer casting can violate alignment rules, aliasing assumptions, and hide serious bugs."
  },
  {
    "id": 57,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=1;\nprintf(\"%d\", (x++, x++, x++, x));",
    "options": ["1", "2", "3", "4"],
    "answerIndex": 3,
    "explanation": "Each comma introduces a sequence point. x is incremented three times sequentially, resulting in x=4."
  },
  {
    "id": 58,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is the comma operator rarely recommended?",
    "options": [
      "Slow",
      "Hard to read",
      "Deprecated",
      "Undefined behavior"
    ],
    "answerIndex": 1,
    "explanation": "Although safe, the comma operator reduces readability and increases cognitive load."
  },
  {
    "id": 59,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=0;\nprintf(\"%d\", a++ && a++);",
    "options": ["0", "1", "Undefined", "Compilation error"],
    "answerIndex": 0,
    "explanation": "The first operand evaluates to false, so the second a++ is not evaluated due to short-circuiting."
  },
  {
    "id": 60,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does short-circuiting help avoid undefined behavior?",
    "options": [
      "Compiler inserts checks",
      "Stops evaluation early",
      "Reduces memory access",
      "Guarantees sequence point"
    ],
    "answerIndex": 1,
    "explanation": "By not evaluating later operands, side effects that could cause undefined behavior are avoided."
  },
  {
    "id": 61,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=5;\nprintf(\"%d\", x = (x++, x+2));",
    "options": ["7", "6", "5", "Undefined behavior"],
    "answerIndex": 1,
    "explanation": "The comma operator introduces a sequence point. First x++ makes x=6, then x+2 evaluates to 8, but assignment happens after evaluation order rules — final value stored is 6."
  },
  {
    "id": 62,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is modifying and assigning the same variable risky even with sequence points?",
    "options": [
      "Compiler bug",
      "Hard to reason evaluation order",
      "Always undefined behavior",
      "Stack corruption"
    ],
    "answerIndex": 1,
    "explanation": "Even when defined, such expressions are hard to read and reason about, increasing the risk of subtle logical bugs."
  },
  {
    "id": 63,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=1;\nprintf(\"%d\", a + (a=10));",
    "options": ["11", "10", "Undefined behavior", "Compilation error"],
    "answerIndex": 2,
    "explanation": "The variable a is modified and read again without a sequence point. The order of evaluation is unspecified, leading to undefined behavior."
  },
  {
    "id": 64,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is reading and writing the same scalar object without a sequence point undefined?",
    "options": [
      "CPU limitation",
      "Compiler freedom",
      "Memory alignment",
      "Runtime overhead"
    ],
    "answerIndex": 1,
    "explanation": "The C standard allows compilers to reorder evaluations freely, so such expressions cannot have a predictable result."
  },
  {
    "id": 65,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=0;\nprintf(\"%d\", ++x || ++x);",
    "options": ["1", "2", "Undefined behavior", "Compilation error"],
    "answerIndex": 0,
    "explanation": "++x makes x=1, which is true. Due to short-circuiting, the second ++x is not evaluated."
  },

  {
    "id": 66,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does logical OR introduce a sequence point?",
    "options": [
      "Syntax rule",
      "Short-circuit guarantee",
      "Compiler optimization",
      "Historical reason"
    ],
    "answerIndex": 1,
    "explanation": "Logical operators guarantee left-to-right evaluation and stop once the result is determined."
  },
  {
    "id": 67,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=5;\nprintf(\"%d\", a | a++);",
    "options": ["5", "6", "Undefined behavior", "Compilation error"],
    "answerIndex": 2,
    "explanation": "Bitwise OR does not introduce a sequence point. a is read and modified without defined order, causing undefined behavior."
  },
  {
    "id": 68,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why are bitwise operators more dangerous with side effects?",
    "options": [
      "Lower precedence",
      "No short-circuiting",
      "Compiler warnings",
      "Runtime checks"
    ],
    "answerIndex": 1,
    "explanation": "Bitwise operators always evaluate both operands, which can trigger undefined behavior when side effects are present."
  },
  {
    "id": 69,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=3;\nprintf(\"%d\", a & ++a);",
    "options": ["2", "3", "4", "Undefined behavior"],
    "answerIndex": 3,
    "explanation": "The variable a is modified and read again without a sequence point, resulting in undefined behavior."
  },
  {
    "id": 70,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does C not define evaluation order for most operators?",
    "options": [
      "Language simplicity",
      "Portability and optimization",
      "Hardware differences",
      "Backward compatibility"
    ],
    "answerIndex": 1,
    "explanation": "Leaving order unspecified allows compilers to optimize code efficiently across different architectures."
  },

  {
    "id": 71,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a[]={1,2,3};\nprintf(\"%d\", sizeof(a)/sizeof(a[0]));",
    "options": ["2", "3", "Depends", "Undefined"],
    "answerIndex": 1,
    "explanation": "The expression correctly computes the number of elements in the array at compile time."
  },
  {
    "id": 72,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does sizeof(array) not work the same inside functions?",
    "options": [
      "Compiler bug",
      "Arrays decay to pointers",
      "Stack memory",
      "Undefined behavior"
    ],
    "answerIndex": 1,
    "explanation": "When passed to a function, arrays decay into pointers, losing size information."
  },
  {
    "id": 73,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nvoid f(int a[]){ printf(\"%zu\", sizeof(a)); }\nint main(){ int x[10]; f(x); }",
    "options": ["40", "10", "8", "Undefined"],
    "answerIndex": 2,
    "explanation": "Inside the function, a is treated as int*, so sizeof returns pointer size (typically 8 bytes)."
  },
  {
    "id": 74,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does array decay exist in C?",
    "options": [
      "Simplify syntax",
      "Reduce memory usage",
      "Enable pointer arithmetic",
      "Historical and design reasons"
    ],
    "answerIndex": 3,
    "explanation": "Array decay comes from early C design choices and supports efficient pointer-based access."
  },
  {
    "id": 75,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint a=10;\nint *p=&a;\nprintf(\"%d\", *p++);",
    "options": ["10", "11", "Undefined", "Compilation error"],
    "answerIndex": 0,
    "explanation": "*p++ is parsed as *(p++). The value pointed to is printed, then the pointer is incremented."
  },

  {
    "id": 76,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is p++ safer than ++*p in pointer-heavy code?",
    "options": [
      "Better performance",
      "Clearer intent",
      "Avoids undefined behavior",
      "Compiler preference"
    ],
    "answerIndex": 1,
    "explanation": "Incrementing the pointer is often clearer and avoids accidentally modifying the pointed value."
  },
  {
    "id": 77,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nprintf(\"%d\", sizeof(void*));",
    "options": ["4", "8", "Depends on architecture", "Undefined"],
    "answerIndex": 2,
    "explanation": "The size of a pointer depends on the system architecture, commonly 8 bytes on 64-bit systems."
  },
  {
    "id": 78,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why must all object pointers have the same size?",
    "options": [
      "Compiler simplification",
      "Standard requirement",
      "Memory alignment",
      "Optimization"
    ],
    "answerIndex": 1,
    "explanation": "The C standard requires that all object pointers can represent any object address, implying equal size."
  },
  {
    "id": 79,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=5;\nprintf(\"%d\", *(char*)&x);",
    "options": ["5", "Undefined", "Depends on endianness", "Compilation error"],
    "answerIndex": 2,
    "explanation": "Accessing an int through a char pointer is allowed, but the value depends on system endianness."
  },
  {
    "id": 80,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is char* allowed to alias any object?",
    "options": [
      "Compiler optimization",
      "Standard exception",
      "Hardware limitation",
      "Undefined behavior"
    ],
    "answerIndex": 1,
    "explanation": "The C standard explicitly allows char pointers to access object representations byte by byte."
  },

  {
    "id": 81,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=0x01020304;\nprintf(\"%x\", *(unsigned char*)&x);",
    "options": ["1", "2", "4", "Depends on endianness"],
    "answerIndex": 3,
    "explanation": "The first byte of the integer depends on whether the system is little-endian or big-endian."
  },
  {
    "id": 82,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is endianness important in low-level C programming?",
    "options": [
      "Affects syntax",
      "Affects portability",
      "Affects compilation",
      "Affects linking"
    ],
    "answerIndex": 1,
    "explanation": "Different byte orders can change how data is interpreted when accessed at byte level."
  },
  {
    "id": 83,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint *p = malloc(sizeof *p);\nprintf(\"%d\", p != NULL);",
    "options": ["0", "1", "Undefined", "Compilation error"],
    "answerIndex": 1,
    "explanation": "malloc returns NULL on failure, otherwise a valid pointer. The comparison checks allocation success."
  },
  {
    "id": 84,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is sizeof *p preferred over sizeof(type)?",
    "options": [
      "Shorter syntax",
      "Avoids type mismatch bugs",
      "Faster compilation",
      "Compiler optimization"
    ],
    "answerIndex": 1,
    "explanation": "Using sizeof *p automatically adapts to type changes, reducing maintenance errors."
  },
  {
    "id": 85,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint *p = malloc(0);\nprintf(\"%d\", p == NULL);",
    "options": ["0", "1", "Undefined", "Implementation-defined"],
    "answerIndex": 3,
    "explanation": "malloc(0) may return NULL or a unique pointer depending on implementation."
  },

  {
    "id": 86,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is malloc(0) dangerous?",
    "options": [
      "Always returns NULL",
      "May return non-NULL pointer",
      "Causes memory leak",
      "Undefined behavior"
    ],
    "answerIndex": 1,
    "explanation": "Code that assumes malloc(0) returns NULL may break on systems where it returns a valid pointer."
  },
  {
    "id": 87,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint *p = realloc(NULL, sizeof(int));\nprintf(\"%d\", p != NULL);",
    "options": ["0", "1", "Undefined", "Compilation error"],
    "answerIndex": 1,
    "explanation": "realloc with NULL behaves like malloc, allocating new memory."
  },
  {
    "id": 88,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why must realloc result be stored carefully?",
    "options": [
      "Avoid memory leak",
      "Avoid double free",
      "Avoid undefined behavior",
      "All of the above"
    ],
    "answerIndex": 3,
    "explanation": "If realloc fails and returns NULL, the original pointer is lost if overwritten."
  },
  {
    "id": 89,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=5;\nprintf(\"%d\", *(int*)((char*)&x));",
    "options": ["5", "Undefined", "Depends on endianness", "Compilation error"],
    "answerIndex": 1,
    "explanation": "Casting char* back to int* may violate alignment requirements, causing undefined behavior."
  },
  {
    "id": 90,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is misaligned access undefined?",
    "options": [
      "Compiler choice",
      "CPU alignment constraints",
      "Memory protection",
      "Language syntax"
    ],
    "answerIndex": 1,
    "explanation": "Some CPUs cannot handle misaligned memory access, so the C standard leaves it undefined."
  },

  {
    "id": 91,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nvolatile int x=0;\nwhile(x==0){}\nprintf(\"Done\");",
    "options": ["Infinite loop", "Done", "Undefined", "Compilation error"],
    "answerIndex": 1,
    "explanation": "volatile prevents the compiler from optimizing away reads of x, allowing the loop to observe external changes."
  },
  {
    "id": 92,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is volatile not a synchronization primitive?",
    "options": [
      "No atomicity",
      "No memory ordering",
      "No mutual exclusion",
      "All of the above"
    ],
    "answerIndex": 3,
    "explanation": "volatile only prevents optimization; it does not guarantee atomic operations or thread safety."
  },
  {
    "id": 93,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=1;\nint *restrict p=&x;\nprintf(\"%d\", *p);",
    "options": ["1", "Undefined", "Depends", "Compilation error"],
    "answerIndex": 0,
    "explanation": "Using restrict correctly imposes aliasing guarantees, but does not change behavior here."
  },
  {
    "id": 94,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does restrict enable optimization?",
    "options": [
      "Prevents pointer arithmetic",
      "Prevents aliasing assumptions",
      "Allows aggressive reordering",
      "Reduces memory usage"
    ],
    "answerIndex": 2,
    "explanation": "restrict tells the compiler that pointers do not alias, allowing safer optimizations."
  },
  {
    "id": 95,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nint x=5;\nint *p=&x;\nint **q=&p;\nprintf(\"%d\", **q);",
    "options": ["5", "Address", "Undefined", "Compilation error"],
    "answerIndex": 0,
    "explanation": "Double dereferencing accesses the original variable x."
  },

  {
    "id": 96,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why are double pointers commonly used?",
    "options": [
      "Performance",
      "Dynamic allocation APIs",
      "Memory alignment",
      "Stack usage"
    ],
    "answerIndex": 1,
    "explanation": "They allow functions to modify pointer values, commonly used in allocation and data structure manipulation."
  },
  {
    "id": 97,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nprintf(\"%d\", 1/0);",
    "options": ["0", "Infinity", "Undefined behavior", "Compilation error"],
    "answerIndex": 2,
    "explanation": "Integer division by zero is undefined behavior in C."
  },
  {
    "id": 98,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why is integer division by zero undefined?",
    "options": [
      "Hardware trap differences",
      "Compiler optimization",
      "Language simplicity",
      "Runtime overhead"
    ],
    "answerIndex": 0,
    "explanation": "Different architectures handle division by zero differently, so the C standard leaves it undefined."
  },
  {
    "id": 99,
    "type": "code",
    "difficulty": "superhard",
    "question": "What is the output?\nprintf(\"%d\", sizeof(1 ? 1.0 : 1));",
    "options": ["4", "8", "Depends", "Undefined"],
    "answerIndex": 1,
    "explanation": "The conditional operator yields a common type. 1.0 is double, so the result type is double."
  },
  {
    "id": 100,
    "type": "concept",
    "difficulty": "superhard",
    "question": "Why does the conditional operator perform type promotion?",
    "options": [
      "Simplify syntax",
      "Ensure type consistency",
      "Avoid undefined behavior",
      "Compiler optimization"
    ],
    "answerIndex": 1,
    "explanation": "Both branches must produce a compatible type so the expression has a well-defined result type."
  }
]
